# Basic Pentesting

## I- Scanning

On utilise nmap `nmap -sC -sV <target ip>` ou tu peux faire un nmap agressif `nmap -A <target ip>`

On regarde les ports ouvert et en fonction on peut essayer de se connecter aux services disponible (ex: HTTP, SSH, SMB etc…)

* Ici on peut voir un service SSH, SMB, un serveur web en additionnant avec Jserv et Tomcat

On se connecte sur le serveur web qui tourne sur le port 80.

## II- Enumération

On utilise **gobuster** lors de cette étape pour découvrir les dossier présent sous la page web:

`gobuster dir -u http://<ip-cible> -w <wordlist>`

chemin de wordlists:

* /usr/share/wordlists/dirb/common.txt
* /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
* /usr/share/wordlists/rockyou.txt

dir va spécifier le mode ‘dossier’ (ou directories - nous cherchons la dossier cachés) , - u http://\<ip-cible> spécifie l’url.

Ici nous obtenons deux dossier intéressant :

* /development: qui contient 2 fichier texte dev.txt et j.txt
* /server-status

On lit dans j.txt que -J’s mot de passe est faible et dans dev.txt qu’il utilise la version Apache 2.5.12 ainsi que la version 2.5.12 de SMB, cela peut être utiliser comme point d’entrée pour la phase d’exploitation.

## III- Exploitation

On jette d’abord un œil à SMB. Pour énumérer et gagner des informations à propos de SMB nous pouvons utiliser **enum4linux** script dans Kali avec l’option **-a** qui récupère la userlist, sharelist, information de politique de mot de passe, group et liste de membres..

```jsx
enum4linux -a <ip-cible>
```

Dans la section user on voit les utilisateurs: kay et jan.

On se rappelle que J (soit jan) à un mot de passe très faible, on peut donc supposer qu’il possède un accès ssh pour aller sur la machine. On va donc essayer de cracker son mot de passe SSH pour gagner des accès sur la machine user

Pour cela, on utilise **Hydra** pour bruteforce an utilisant le username “jan” et une wordlist.

```jsx
hydra -l jan -P /usr/share/wordlists/rockyou.txt ssh://<ip-cible>
```

On laisse tourner et nous pouvons utiliser le mot de passe retourné pour se connecter en ssh sur la machine

```jsx
ssh jan@<ip-cible>
```

## IV- Escalation de privilège

Nous pouvons commencer par faire de l’énumération sur la machine, lister les fichier, chercher les fichiers cachés, nous trouvons un fichier “pass.bak” dans /home/kay mais seul kay peut le lire. On repère un dossier ‘.ssh’ qui doit normalement contenir les clés privés SSH pour se connecter à distance. Le dossier contient **authorized\_keys**, **id\_rsa** et **id\_rsa.pub.**

En regardant les permissions sur **id\_rsa** (private key) tout le monde peut la lire (ce qui n’est pas normal) nous pouvons donc la copier pour se connecter en ssh à kay.

```jsx
cat id_rsa
```

Une fois copié, nous allons sur notre machine et nous créons un fichier avec notre nouvel clé. Ne pas oublier de changer les permissions du fichier

```jsx
chmod 600 <fichier>
```

```jsx
ssh -i <fichier> kay@<ip-cible>
```

Malheureusement, nous avons une passphrase à la connexion en SSH, c’est utiliser pour chiffrer la key privé. In va donc utiliser **John the Ripper.**

Pour convertir à un format approprier pour John the Ripper on utilise **ssh2john**

```jsx
sudo python [ssh2john.py](<http://ssh2john.py>) <fichier id_rsa> > <nouveau-fichier>
```

```jsx
sudo john <nouveau-fichier> —wordlist=/usr/share/wordlists/rockyou.txt
```

On obtient la passphrase, on peut donc se connecter à nouveau en ssh sur kay

Nous pouvons mtn lire ‘pass.bak’ trouver avant dans /home/kay

Il est temps de check les permissions sudo

```jsx
sudo -l
```

Nous pouvons passer en root (sudo su) en utilisant le mot de passe dans ‘pass.bak’, on obtient un shell root et en se baladant, on peut trouver le ‘flag.txt’.
